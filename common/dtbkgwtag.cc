/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

// Your description goes here...

#include "dtbkgwtag.h"



// ROOT includes
#include "TF1.h"
#include "RooAbsReal.h"
#include "RooRealVar.h"

// BASF includes
#include "tatami/libcnvl.h"

// Local includes
#include "constants.h"
#include "tools.h"

//ClassImp(DSRhoPDF)

DtBKGWtag::DtBKGWtag(const char *name, const char *title, const bool _CKM_favored, const bool _mixing,
             RooAbsReal& _dt,
             RooAbsReal& _expmc,
             RooAbsReal& _expno,
             RooAbsReal& _vrerr6,
             RooAbsReal& _vterr6,
             RooAbsReal& _tau,
             RooAbsReal& _dm,
             RooAbsReal& _wtag,
             RooAbsReal& _mu_main,
             RooAbsReal& _mu_tail,
             RooAbsReal& _S_main,
             RooAbsReal& _S_tail,
             RooAbsReal& _f_tail
            ) :
                RooAbsPdf(name,title),
                dt("dt","dt",this,_dt),
                expmc("expmc","expmc",this,_expmc),
                expno("expno","expno",this,_expno),
                vrerr6("vrerr6","vrerr6",this,_vrerr6),
                vterr6("vterr6","vterr6",this,_vterr6),
                tau("tau","tau",this,_tau),
                dm("dm","dm",this,_dm),
                wtag("wtag","wtag",this,_wtag),
                mu_main("mu_main","mu_main",this,_mu_main),
                mu_tail("mu_tail","mu_tail",this,_mu_tail),
                S_main("S_main","S_main",this,_S_main),
                S_tail("S_tail","S_tail",this,_S_tail),
                f_tail("f_tail","f_tail",this,_f_tail),

                CKM_favored(_CKM_favored),
                mixing(_mixing)
{
}


DtBKGWtag::DtBKGWtag(const DtBKGWtag& other, const char* name) :
            RooAbsPdf(other,name),
            dt("dt",this,other.dt),
            expmc("expmc",this,other.expmc),
            expno("expno",this,other.expno),
            vrerr6("vrerr6",this,other.vrerr6),
            vterr6("vterr6",this,other.vterr6),
            tau("tau",this,other.tau),
            dm("dm",this,other.dm),
            wtag("wtag",this,other.wtag),
            mu_main("mu_main",this,other.mu_main),
            mu_tail("mu_tail",this,other.mu_tail),
            S_main("S_main",this,other.S_main),
            S_tail("S_tail",this,other.S_tail),
            f_tail("f_tail",this,other.f_tail),

            CKM_favored(other.CKM_favored),
            mixing(other.mixing)
{
}

Double_t DtBKGWtag::evaluate() const {
    double pdf = 0;
    double norm = 0;
    // *zerr is actually zerr**2 (we are passing *err6)
    const double sigma_main = S_main * sqrt(vrerr6 + vterr6);
    const double sigma_tail = S_tail * sqrt(vrerr6 + vterr6);

    const double pdf_const_main = Belle::Ef_conv_gauss(dt, tau, mu_main, sigma_main);
    const double pdf_const_tail = Belle::Ef_conv_gauss(dt, tau, mu_tail, sigma_tail);

    const double norm_const_main = Belle::norm_Ef_conv_gauss(
        constants::cuts::dt_low, constants::cuts::dt_high, tau, mu_main, sigma_main);
    const double norm_const_tail = Belle::norm_Ef_conv_gauss(
        constants::cuts::dt_low, constants::cuts::dt_high, tau, mu_tail, sigma_tail);

    const double pdf_cos_main = Belle::Mf_conv_gauss(dt, tau, dm, mu_main, sigma_main) * 0.5 / tau;
    const double pdf_cos_tail = Belle::Mf_conv_gauss(dt, tau, dm, mu_tail, sigma_tail) * 0.5 / tau;

    const double norm_cos_main = Belle::norm_Mf_conv_gauss(
        constants::cuts::dt_low, constants::cuts::dt_high, tau, dm, mu_main, sigma_main) * 0.5 / tau;
    double norm_cos_tail = Belle::norm_Mf_conv_gauss(
        constants::cuts::dt_low, constants::cuts::dt_high, tau, dm, mu_tail, sigma_tail) * 0.5 / tau;

    const bool mc = (expmc == 2) ? 1 : 0;
    const double r = 1 - 2 * wtag;
    const int r_bin = tools::GetRBin(r);
    const double wtag_binned = tools::GetWTag(expno, r_bin, mc);
    const double r_binned = 1 - 2 * wtag_binned;

    const double sign = -1 + 2*CKM_favored;

    // This happens when we use the --notail switch. It's OK, but needs to be
    // taken care of otherwise the norm is nan as well.
    if (isnan(norm_cos_tail)) {
        norm_cos_tail = 0;
    }

    if (mixing) {
        pdf = (1 - f_tail) * (pdf_const_main + sign * r_binned * pdf_cos_main) +
              f_tail       * (pdf_const_tail + sign * r_binned * pdf_cos_tail);


        norm = (1 - f_tail) * (norm_const_main + sign * r_binned * norm_cos_main) +
               f_tail       * (norm_const_tail + sign * r_binned * norm_cos_tail);
    } else {
        pdf = (1 - f_tail) * (CKM_favored - sign * wtag_binned) * pdf_const_main +
              f_tail       * (CKM_favored - sign * wtag_binned) * pdf_const_tail;

        norm = (1 - f_tail) * (CKM_favored - sign * wtag_binned) * norm_const_main +
               f_tail       * (CKM_favored - sign * wtag_binned) * norm_const_tail;
    }

    return pdf/norm;
}

Int_t DtBKGWtag::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const {
    if(matchArgs(allVars,analVars,dt)) return 1;

    return 0 ;
}

Double_t DtBKGWtag::analyticalIntegral(Int_t code, const char* rangeName) const {
    switch(code) {
    case 1: // Int[g,{dt}]
        return 1;
    default:
        return 0;
    }

}
